use crossterm::{
    event::{self, Event as CEvent, KeyCode},
    terminal,
};
use reqwest::blocking;
use std::{
    env, io,
    sync::mpsc,
    thread,
    time::{Duration, Instant},
};
use tui::{
    backend,
    text::{Span, Spans},
    layout::{Constraint, Direction, Layout},
    style::{Color, Modifier, Style},
    widgets::{Block, Borders, Cell, Paragraph, Row, Table, TableState, Wrap},
    Terminal,
};

// The subdomain to access
const SUBDOMAIN: &str = "zccticketchallenge";
// The account to try to access
const ACCT_NAME: &str = "david.siher@gmail.com";

// The maximum number of tickets displayed on a page
// (25 was requested in the specs)
const MAX_TIX: u8 = 25;

// The tickrate of the terminal instance
const TICK_RATE: u64 = 250;

/// The representation of a ticket
#[derive(Clone)]
struct Ticket {
    /// The unique id generated by Zendesk
    id: String,
    /// The priority level of this ticket
    priority: String,
    /// The subject field for the ticket
    subject: String,
    /// The id of the user who submitted the ticket
    creator: String,
    /// When this ticket was created (following ISO 8601 format)
    created: String,
    /// The longer description of this ticket
    description: String,
    /// False if the id is not found (as id is not labeled required on the Zendesk API)
    viewable: bool,
}

/// The representation of a page
#[derive(Clone)]
struct Page {
    /// Whether Zendesk's cursor pagination has another page to offer
    has_more: bool,
    /// The url of the next page if it exists, "none" otherwise
    next: String,
    /// The url of the previous page if it exists, "none" otherwise
    prev: String,
    /// A vector of all tickets contained in this page
    tickets: Vec<Ticket>,
}

/// Returns a parsed json of a desired page of tickets accessed via the Zendesk API
/// using the constant subdomain and account name
///
/// # Arguments
///
/// * `client` - the intialized reqwest client
/// * `token` - a valid API token for the account being accessed
/// * `url` - the url of the page to be accessed
///
/// # Note
///
/// Will propagate errors from reqwest if encountered
/// Requires: valid API token provided, *valid json received from Zendesk API*
fn request_page(
    client: &blocking::Client,
    token: &String,
    url: &str,
) -> Result<json::JsonValue, reqwest::Error> {
    // Send get request with const account and provided token.
    let resp = client
        .get(url)
        // Format the basic auth for Zendesk API
        .basic_auth(format!("{}/token", ACCT_NAME), Some(token))
        .send()?;
    // Parse and return the response as json
    match json::parse(&resp.text()?) {
        Ok(json) => Ok(json),
        Err(_) => {
            println!("Unable to parse Zendesk API response. Try again later.");
            std::process::exit(1);
        }
    }
}

/// Returns a `Ticket` representation of the provided json for a ticket
///
/// # Arguments
/// * `ticket_json` - a `JsonValue` representing a ticket
fn parse_ticket(ticket_json: &json::JsonValue) -> Ticket {
    Ticket {
        id: ticket_json["id"]
            .as_number()
            .unwrap_or(json::number::Number::from(-1))
            .to_string(),
        subject: String::from(ticket_json["subject"].as_str().unwrap_or("N/A")),
        creator: String::from(ticket_json["submitter_id"].as_str().unwrap_or("N/A")),
        created: String::from(ticket_json["created_at"].as_str().unwrap_or("N/A")),
        priority: String::from(ticket_json["priority"].as_str().unwrap_or("N/A")),
        description: String::from(ticket_json["description"].as_str().unwrap_or("No description")),
        viewable: ticket_json["id"].is_number(),
    }
}

/// Returns a `Page` representation of the provided json for a page of tickets
///
/// # Arguments
/// * `page_json` - a `JsonValue` representing a page of tickets
fn parse_page(page_json: json::JsonValue) -> Page {
    Page {
        has_more: page_json["meta"]["has_more"].as_bool().unwrap_or(false),
        next: String::from(page_json["links"]["next"].as_str().unwrap_or("none")),
        prev: String::from(page_json["links"]["prev"].as_str().unwrap_or("none")),
        tickets: page_json["tickets"].members().map(parse_ticket).collect(),
    }
}

/// Converts a `Ticket` into a vector that can be used to create rows for the TUI
/// If the `Ticket` cannot be viewed (has no id) then it is discarded.
///
/// # Arguments
/// * `tickets` - a vector of tickets
fn row_generator(tickets: Ticket) -> Option<Vec<String>> {
    let mut result = Vec::new();
    if tickets.viewable {
        result.push(tickets.id);
        result.push(tickets.priority);
        result.push(tickets.subject);
        result.push(tickets.creator);
        result.push(tickets.created);
        Some(result)
    } else {
        None
    }
}

/// Enum used for input handling by the TUI
enum Event<I> {
    Input(I),
    Tick,
}

/// Enum used to keep track of view in TUI
enum View {
    Table,
    Info,
}

/// Closes process down when encountering a reqwest error (trouble connecting to the Zendesk API)
/// 
/// Could be improved by invoking a retry after a delay
fn handle_reqwest_errors() {
    println!("Failed to connect to the Zendesk API. Try again later.");
    std::process::exit(1);
}

/// Initializes the rusty ticketer with a provided access token
/// # Requires: 
/// the first command line argument must be a valid API token
/// 
/// This terminal user interface (TUI) is adapted from a variety of tui crate examples
/// 
/// # Note
/// All expect statements are used for values that had no documented failure cases.
fn main() {
    let args: Vec<String> = env::args().collect();
    let default = args.get(0).expect("This is guaranteed to exist");
    let token = match args.get(1) {
        Some(value) => value,
        None => default
    };
    if token.eq(default) {
        println!("You must provide a valid API token as an argument for the ticket viewer to launch.");
        std::process::exit(1);
    }


    // Creates the reqwest Client for use in all web request functionality
    // Uses blocking  functionality as async does not really help performance.
    // Linux requires OpenSSL to be installed (!)
    let client = match blocking::Client::builder().build() {
        Ok(clnt) => clnt,
        Err(_) => { println!(
            "The reqwest client was unable to initialize a TLS backend.\n\
             For Linux usage, make sure you have installed OpenSSL 1.1.1");
             std::process::exit(1);
        }
    };

    // Create the URL used to access the initial ticket page as per Zendesk API docs
    let url = format!(
        "https://{}.zendesk.com/api/v2/tickets.json?page[size]={}",
        SUBDOMAIN, MAX_TIX
    );

    // Attempts to request the initial set of tickets.
    let init_tickets = request_page(&client, token, &url);
    match init_tickets {
        Err(_) => handle_reqwest_errors(),
        Ok(parsed_json) => {
            if !parsed_json["error"].is_null() {
                println!("Failed to authenticate you. Make sure the API token is valid for the constant account.");
                std::process::exit(1);
            }
            let mut curr_page = parse_page(parsed_json);
            let mut cached_prev = curr_page.prev.clone();
            // Start creating a TUI

            // Enter raw mode for a nicer terminal experience
            terminal::enable_raw_mode().expect("Failed to enter raw mode.");

            // Initialize terminal
            let stdout = io::stdout();
            let backend = backend::CrosstermBackend::new(stdout);
            let mut terminal = Terminal::new(backend).expect("Failed to initialize UI");
            terminal.clear().expect("Failed to clear the terminal.");

            // Begin input handling
            let (tx, rx) = mpsc::channel();
            let tick_rate = Duration::from_millis(TICK_RATE);

            // Spawn a thread in order to keep track of input handling
            thread::spawn(move || {
                let mut last_tick = Instant::now();
                loop {
                    // Poll for tick rate duration, send tick event if no inputs found.
                    let timeout = tick_rate
                        .checked_sub(last_tick.elapsed())
                        .unwrap_or_else(|| Duration::from_secs(0));
                    if event::poll(timeout).unwrap() {
                        if let CEvent::Key(key) = event::read().unwrap() {
                            tx.send(Event::Input(key)).unwrap();
                        }
                    }
                    if last_tick.elapsed() >= tick_rate {
                        tx.send(Event::Tick).unwrap();
                        last_tick = Instant::now();
                    }
                }
            });

            // Define current active view
            let mut active_view = View::Table;
            // Define current selected ticket
            let mut ticket_table_state = TableState::default();
            // Define how many times it is valid to go back a page (more explanation later)
            let mut left_avail = 0;
            // Initialize selected ticket to 0
            ticket_table_state.select(Some(0));

            // Begin TUI loop
            loop {
                terminal
                    .draw(|canvas| {
                        // Initialize a few style things
                        let selected_style = Style::default().fg(Color::LightYellow);
                        let normal_style = Style::default().add_modifier(Modifier::UNDERLINED);
                        let header_cells = ["ID", "Priority", "Subject", "Submitter", "Date"]
                            .iter()
                            .map(|h| Cell::from(*h).style(Style::default()));
                        let header = Row::new(header_cells)
                            .style(normal_style)
                            .height(1)
                            .bottom_margin(1);

                        // Divide terminal into two sections (views and instructions)
                        let sections = Layout::default()
                            .direction(Direction::Vertical)
                            .constraints([
                                Constraint::Min(2), Constraint::Length(2),
                            ].as_ref(),)
                            .split(canvas.size());
                        
                        // Create instructions for both views
                        let instructions_table = Paragraph::new("UP/DOWN to scroll, RIGHT/LEFT to switch pages, ENTER to view a ticket, Q to quit.")
                        .block(
                            Block::default()
                            .title("Instructions")
                        );

                        let instructions_info = Paragraph::new("BACKSPACE to return to the table, Q to quit.")
                        .block(
                            Block::default()
                            .title("Instructions")
                        );
                        
                        // Decide between the two views to render
                        match active_view {
                            View::Table => { 
                                // Begin the rendering process for the ticket table
                                let tickets: Vec<Vec<String>> = curr_page
                                    .clone()
                                    .tickets
                                    .into_iter()
                                    .map(row_generator)
                                    .flatten()
                                    .collect();
                                let rows = tickets.iter().map(|item| {
                                    let cells = item.iter().map(|c| Cell::from(&**c));
                                    Row::new(cells).height(1 as u16).bottom_margin(1)
                                });
                                let t = Table::new(rows)
                                    .header(header)
                                    .block(Block::default()
                                    .borders(Borders::ALL)
                                    .title("Rusty-Ticketer"))
                                    .highlight_style(selected_style)
                                    .highlight_symbol(">> ")
                                    .column_spacing(2)
                                    .widths(&[
                                        Constraint::Percentage(5),
                                        Constraint::Length(8),
                                        Constraint::Percentage(40),
                                        Constraint::Percentage(15),
                                        Constraint::Length(10),
                                    ]);
                                canvas.render_stateful_widget(t, sections[0], &mut ticket_table_state);
                                canvas.render_widget(instructions_table, sections[1]);
                            }
                            View::Info => {
                                // Begin the rendering process for a single ticket
                                if let Some(selected) = ticket_table_state.selected() {
                                    let ticket = curr_page.tickets[selected].clone();
                                    let subject = Style::default().add_modifier(Modifier::BOLD);
                                    let text = vec![
                                        Spans::from(Span::styled(ticket.subject, subject)),
                                        Spans::from(Span::raw(format!("{} opened this ticket on {}", ticket.creator, ticket.created))),
                                        Spans::from(Span::raw("")),
                                        Spans::from(Span::raw(ticket.description))
                                    ];
                                    let info = Paragraph::new(text).block(Block::default()
                                        .borders(Borders::ALL)
                                        .title(format!("ID: {}", ticket.id)))
                                        .wrap(Wrap { trim: true });
                                    canvas.render_widget(info, sections[0]);
                                    canvas.render_widget(instructions_info, sections[1]);
                                }
                            }
                        }
                    })
                    .expect("Failed to draw TUI");

                // Event handling
                match rx
                    .recv()
                    .expect("Something shut down a thread we were relying on.")
                {
                    Event::Input(event) => match event.code {
                        // Handle quit on 'Q' or 'q'
                        KeyCode::Char('q') | KeyCode::Char('Q') => {
                            terminal::disable_raw_mode().expect("Failed to disable raw mode.");
                            terminal.clear().expect("Failed to clear terminal.");
                            break;
                        }
                        // Handle scrolling down
                        KeyCode::Down => {
                            if let Some(selected) = ticket_table_state.selected() {
                                let ticket_num = curr_page.tickets.len();
                                ticket_table_state.select(Some((selected + 1) % ticket_num));
                            }
                        }
                        // Handle scrolling up
                        KeyCode::Up => {
                            if let Some(selected) = ticket_table_state.selected() {
                                let ticket_num = curr_page.tickets.len();
                                // Cannot use mod as selected is unsigned, results in overflow
                                if selected > 0 {
                                    ticket_table_state.select(Some(selected - 1));
                                } else {
                                    ticket_table_state.select(Some(ticket_num - 1));
                                }
                            }
                        }
                        // Handle next page
                        KeyCode::Right => {
                            if curr_page.has_more && matches!(active_view, View::Table) {
                                let page_json = request_page(&client, token, &curr_page.next);
                                match page_json {
                                    Err(_) => handle_reqwest_errors(),
                                    Ok(parsed_json) => {
                                        // Workaround to prevent being able to go back from the first page
                                        left_avail += 1;
                                        cached_prev = curr_page.prev;
                                        curr_page = parse_page(parsed_json);
                                        ticket_table_state.select(Some(0));
                                    }
                                }
                            }
                        },
                        // Handle previous page
                        KeyCode::Left => {
                            // Check that there are left pages available as per the workaround
                            if matches!(active_view, View::Table) && left_avail > 0 {
                                // In an edge case in the Zendesk API, it is possible to go to a next page
                                // that has no prev or next values, therefore the prior prev is kept cached
                                // so that if this happens, it can be used to escape from a blank screen.
                                let prev = if curr_page.prev.eq("none") {
                                    &cached_prev
                                } else {
                                    &curr_page.prev
                                };
                                let page_json = request_page(&client, token, prev);
                                match page_json {
                                    Err(_) => handle_reqwest_errors(),
                                    Ok(parsed_json) => {
                                        left_avail -= 1;
                                        curr_page = parse_page(parsed_json);
                                        ticket_table_state.select(Some(0));
                                    }
                                }
                            }
                        },
                        // Handle entering single ticket view
                        KeyCode::Enter => {
                            active_view = View::Info;
                        },
                        // Handle exiting single ticket view
                        KeyCode::Backspace => {
                            active_view = View::Table;
                        }
                        _ => {}
                    },
                    // Handle the tick event that is generated when no input is found
                    Event::Tick => {}
                }
            }
        }
    }
}
